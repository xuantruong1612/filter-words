# L·ªçc ƒë√°p √°n trong file nh∆∞ng c√≥ pts - C·∫£i ti·∫øn ∆∞u ti√™n d·∫•u "-"

import re
import os
import json
import datetime
from pathlib import Path
from typing import List, Tuple, Dict, Set

class QuestionFilter:
    def __init__(self):
        self.default_input_file = "Input.txt"
        self.input_file = ""
        self.log_file = "Log.txt"
        self.config_file = "config.json"
        self.backup_dir = "backups"

    def list_available_files(self) -> List[str]:
        supported_extensions = ['.txt', '.docx', '.doc']
        return sorted([
            file for file in os.listdir('.')
            if any(file.lower().endswith(ext) for ext in supported_extensions)
            and os.path.isfile(file)
        ])

    def get_input_file(self) -> str:
        print("üìÅ Ch·ªçn file input:")
        print("=" * 30)
        files = self.list_available_files()

        if files:
            for i, file in enumerate(files, 1):
                size = os.path.getsize(file)
                size_str = f"{size:,} bytes" if size < 1024 else f"{size/1024:.1f} KB"
                print(f"  ‚ñ´Ô∏è  {i}. {file} ({size_str})")
            print(f"  ‚ñ´Ô∏è  {len(files) + 1}. Nh·∫≠p t√™n file kh√°c")
            print(f"  ‚ñ´Ô∏è  {len(files) + 2}. T·∫°o file '{self.default_input_file}' m·∫´u")

            while True:
                try:
                    choice = input(f"\nCh·ªçn (1-{len(files) + 2}): ").strip()
                    if not choice: continue
                    n = int(choice)
                    if 1 <= n <= len(files):
                        return files[n - 1]
                    elif n == len(files) + 1:
                        return self.get_custom_input_filename()
                    elif n == len(files) + 2:
                        self.create_sample_input()
                        return ""
                except KeyboardInterrupt:
                    print("\nüëã Tho√°t ch∆∞∆°ng tr√¨nh!"); exit(0)
                except:
                    print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!")
        else:
            print("üìÇ Kh√¥ng t√¨m th·∫•y file n√†o!")
            print("1. Nh·∫≠p t√™n file")
            print(f"2. T·∫°o file '{self.default_input_file}' m·∫´u")
            choice = input("Ch·ªçn (1/2): ").strip()
            return self.get_custom_input_filename() if choice == '1' else (self.create_sample_input() or "")

    def get_custom_input_filename(self) -> str:
        while True:
            filename = input("üìù Nh·∫≠p t√™n file input (c√≥ ƒëu√¥i .txt): \n‚û°Ô∏è  ").strip()
            if not filename: continue
            if '.' not in filename:
                filename += '.txt'
                print(f"üîß T·ª± ƒë·ªông th√™m ƒëu√¥i: {filename}")
            if not os.path.exists(filename):
                ch = input("1. Nh·∫≠p l·∫°i | 2. T·∫°o file m·ªõi | 3. Tho√°t (1/2/3): ").strip()
                if ch == '2':
                    with open(filename, "w", encoding="utf-8") as f:
                        f.write("üìù Ghi n·ªôi dung c√¢u h·ªèi d∆∞·ªõi ƒë√¢y:\n\nQuestion 1\n0.3 / 0.3 pts\nV√≠ d·ª•: B·∫°n th·∫•y sao?\n  Tuy·ªát.\n  Tuy·ªát2.\n")
                    return ""
                elif ch == '3':
                    exit(0)
                else:
                    continue
            try:
                with open(filename, 'r', encoding='utf-8') as f:
                    _ = f.read(100)
                return filename
            except:
                print(f"‚ùå Kh√¥ng th·ªÉ ƒë·ªçc file '{filename}'")
                continue

    def create_sample_input(self) -> None:
        try:
            with open(self.default_input_file, "w", encoding="utf-8") as f:
                f.write("Question 1\n0.3 / 0.3 pts\nV√≠ d·ª•: B·∫°n th·∫•y sao?\n  Tuy·ªát.\n  Tuy·ªát2.\n\n")
                f.write("Question 2\n0.5 / 0.5 pts\nC√¢u h·ªèi th·ª© hai:\n  ƒê√°p √°n A\n  ƒê√°p √°n B\n  ƒê√°p √°n C\n\n")
                f.write("Question 3\nIncorrect\n0 / 0.5 pts\nC√¢u sai:\n  Sai A\n  Sai B\n")
        except Exception as e:
            print(f"‚ùå L·ªói t·∫°o file m·∫´u: {e}")

    def backup_file(self, filename: str) -> str:
        try:
            os.makedirs(self.backup_dir, exist_ok=True)
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = f"{self.backup_dir}/{Path(filename).stem}_{timestamp}{Path(filename).suffix}"
            with open(filename, 'r', encoding='utf-8') as src, open(backup_name, 'w', encoding='utf-8') as dst:
                dst.write(src.read())
            return backup_name
        except:
            return ""

    def load_config(self) -> Dict:
        default = {
            "invalid_markers": ["Incorrect", "0 /", "0.0 /"],
            "output_formats": [".txt", ".docx", ".json", ".csv"],
            "auto_backup": True,
            "last_input_file": "",
            "renumber_questions": True
        }
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    return {**default, **json.load(f)}
        except:
            pass
        return default

    def save_config(self, config: Dict) -> None:
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
        except:
            pass

    def read_input_file(self, filename: str) -> str:
        try:
            with open(filename, "r", encoding="utf-8") as f:
                return f.read().strip()
        except UnicodeDecodeError:
            with open(filename, "r", encoding="cp1252") as f:
                return f.read().strip()
        except:
            return ""

    def fix_content_format(self, content: str) -> str:
        fixes = [
            (r"(?<!\n)(Question \d+)", r"\n\1"),
            (r"(Incorrect)(Question \d+)", r"\1\n\2"),
            (r"(\d+(?:\.\d+)?\s*/\s*\d+(?:\.\d+)?\s*pts)([^\n])", r"\1\n\2"),
            (r"\n\s*\n\s*\n", r"\n\n")
        ]
        for pat, rep in fixes:
            content = re.sub(pat, rep, content)
        return content

    def validate_content(self, content: str) -> Tuple[bool, List[str]]:
        errors = []
        if not content:
            return False, ["File r·ªóng"]
        if not re.search(r"\d+(?:\.\d+)?\s*/\s*\d+(?:\.\d+)?\s*pts", content):
            errors.append("Kh√¥ng c√≥ ƒë·ªãnh d·∫°ng ƒëi·ªÉm '... pts'")
        if not re.findall(r"Question \d+", content):
            errors.append("Kh√¥ng c√≥ c√¢u h·ªèi 'Question X'")
        return (len(errors) == 0), errors

    def get_output_filename(self, config: Dict) -> str:
        print("üìù Nh·∫≠p t√™n file output:")
        while True:
            filename = input("T√™n file + ƒëu√¥i (vd: output.txt): ").strip()
            if '.' not in filename:
                print("‚ö†Ô∏è Thi·∫øu ƒëu√¥i file!")
                continue
            ext = Path(filename).suffix.lower()
            if ext not in config["output_formats"]:
                print(f"‚ùå Kh√¥ng h·ªó tr·ª£ '{ext}'")
                continue
            return filename

    def get_invalid_markers(self, config: Dict) -> List[str]:
        print(f"üî¥ T·ª´ kh√≥a sai: {config['invalid_markers']}")
        use_default = input("D√πng m·∫∑c ƒë·ªãnh? (y/n): ").strip().lower()
        if use_default in ['n', 'no']:
            markers = input("Nh·∫≠p t·ª´ kh√≥a (ph√¢n t√°ch b·ªüi d·∫•u ph·∫©y): ").strip()
            if markers:
                return [m.strip() for m in markers.split(',')]
        return config['invalid_markers']

    def get_sort_preference(self, config: Dict) -> bool:
        """H·ªèi ng∆∞·ªùi d√πng c√≥ mu·ªën ƒë√°nh s·ªë l·∫°i t·ª´ 1 kh√¥ng"""
        current = "c√≥" if config.get("renumber_questions", True) else "kh√¥ng"
        print(f"üî¢ ƒê√°nh s·ªë l·∫°i t·ª´ Question 1, 2, 3... (hi·ªán t·∫°i: {current})")
        choice = input("ƒê√°nh s·ªë l·∫°i t·ª´ 1? (y/n): ").strip().lower()
        if choice in ['n', 'no']:
            return False
        return True

    def normalize_question_for_comparison(self, text: str) -> str:
        text = text.strip()
        return re.sub(r'^[-‚Äì‚Ä¢\s]+', '', text).strip()

    def parse_questions(self, content: str) -> List[Tuple[str, str]]:
        pattern = r"(Question\s+(\d+)\n[\s\S]+?)(?=Question\s+\d+\n|\Z)"
        return [(m[1], m[0].split('\n', 1)[1].strip()) for m in re.findall(pattern, content)]

    def sort_questions_by_number(self, questions: List[Tuple[str, str]]) -> List[Tuple[str, str]]:
        """S·∫Øp x·∫øp c√¢u h·ªèi theo s·ªë th·ª© t·ª±"""
        def get_question_number(question_tuple):
            try:
                return int(question_tuple[0])
            except ValueError:
                # N·∫øu kh√¥ng parse ƒë∆∞·ª£c s·ªë, ƒë·∫∑t ·ªü cu·ªëi
                return float('inf')
        
        return sorted(questions, key=get_question_number)

    def filter_questions(self, questions: List[Tuple[str, str]], invalid_markers: List[str], renumber: bool = True) -> Dict:
        # Thu th·∫≠p t·∫•t c·∫£ c√¢u h·ªèi theo n·ªôi dung chu·∫©n h√≥a
        content_groups: Dict[str, List[Tuple[str, str, str, bool]]] = {}  # norm_content -> [(num, body, q_text, has_dash)]
        incorrect: Set[str] = set()

        # S·∫Øp x·∫øp c√¢u h·ªèi theo s·ªë th·ª© t·ª± tr∆∞·ªõc khi x·ª≠ l√Ω
        questions = self.sort_questions_by_number(questions)

        # B∆∞·ªõc 1: Thu th·∫≠p t·∫•t c·∫£ c√¢u h·ªèi v√† nh√≥m theo n·ªôi dung
        for num, body in questions:
            lines = body.splitlines()
            q_text = lines[1].strip() if len(lines) >= 2 else ""
            
            # B·ªè qua c√¢u h·ªèi sai
            if any(m in body for m in invalid_markers):
                incorrect.add(f"Question {num}")
                continue
            
            # Chu·∫©n h√≥a n·ªôi dung ƒë·ªÉ so s√°nh
            norm_content = self.normalize_question_for_comparison(q_text)
            
            # Ki·ªÉm tra xem c√≥ ƒë√°p √°n b·∫Øt ƒë·∫ßu b·∫±ng d·∫•u "-" kh√¥ng
            has_dash_answers = any(line.strip().startswith('-') for line in lines[2:] if line.strip())
            
            # Th√™m v√†o nh√≥m
            if norm_content not in content_groups:
                content_groups[norm_content] = []
            content_groups[norm_content].append((num, body, q_text, has_dash_answers))

        # B∆∞·ªõc 2: Ch·ªçn c√¢u t·ªët nh·∫•t t·ª´ m·ªói nh√≥m
        selected_questions = []
        dup_info = []
        removed = 0

        for norm_content, group in content_groups.items():
            if len(group) == 1:
                # Kh√¥ng c√≥ tr√πng l·∫∑p
                num, body, q_text, has_dash = group[0]
                selected_questions.append((num, body, q_text))
            else:
                # C√≥ tr√πng l·∫∑p - ch·ªçn c√¢u t·ªët nh·∫•t
                removed += len(group) - 1
                
                # Ph√¢n lo·∫°i c√¢u trong nh√≥m
                dash_questions = [(num, body, q_text, has_dash) for num, body, q_text, has_dash in group if has_dash]
                non_dash_questions = [(num, body, q_text, has_dash) for num, body, q_text, has_dash in group if not has_dash]
                
                # LOGIC S·ª¨A: ∆Øu ti√™n tuy·ªát ƒë·ªëi c√¢u c√≥ d·∫•u "-"
                if dash_questions:
                    # C√≥ c√¢u v·ªõi d·∫•u "-", ch·ªçn c√¢u c√≥ s·ªë nh·ªè nh·∫•t trong nh√≥m n√†y
                    best = min(dash_questions, key=lambda x: int(x[0]) if x[0].isdigit() else float('inf'))
                    selected_questions.append((best[0], best[1], best[2]))
                    
                    # Ghi log v·ªÅ c√°c c√¢u b·ªã lo·∫°i (bao g·ªìm c·∫£ c√¢u kh√¥ng c√≥ d·∫•u "-")
                    all_numbers = [q[0] for q in group]
                    rejected_numbers = [q[0] for q in group if q[0] != best[0]]
                    
                    dash_rejected = [q[0] for q in dash_questions if q[0] != best[0]]
                    non_dash_rejected = [q[0] for q in non_dash_questions]
                    
                    log_msg = f"Nh√≥m tr√πng {all_numbers} ‚Üí ch·ªçn Q{best[0]} (c√≥ d·∫•u '-')"
                    if dash_rejected:
                        log_msg += f", lo·∫°i Q{dash_rejected} (c≈©ng c√≥ '-' nh∆∞ng s·ªë l·ªõn h∆°n)"
                    if non_dash_rejected:
                        log_msg += f", lo·∫°i Q{non_dash_rejected} (kh√¥ng c√≥ '-')"
                    
                    dup_info.append(log_msg)
                    
                else:
                    # Kh√¥ng c√≥ c√¢u n√†o c√≥ d·∫•u "-", ch·ªçn c√¢u c√≥ s·ªë nh·ªè nh·∫•t
                    best = min(non_dash_questions, key=lambda x: int(x[0]) if x[0].isdigit() else float('inf'))
                    selected_questions.append((best[0], best[1], best[2]))
                    
                    # Ghi log v·ªÅ c√°c c√¢u b·ªã lo·∫°i
                    all_numbers = [q[0] for q in group]
                    rejected_numbers = [q[0] for q in group if q[0] != best[0]]
                    dup_info.append(f"Nh√≥m tr√πng {all_numbers} ‚Üí ch·ªçn Q{best[0]} (s·ªë nh·ªè nh·∫•t, kh√¥ng c√≥ c√¢u n√†o c√≥ '-'), lo·∫°i: {rejected_numbers}")

        # B∆∞·ªõc 3: S·∫Øp x·∫øp k·∫øt qu·∫£ v√† x·ª≠ l√Ω tr√πng s·ªë
        unique_blocks = []
        seen_numbers: Dict[str, int] = {}
        number_conflicts = []
        
        # S·∫Øp x·∫øp l·∫°i theo s·ªë th·ª© t·ª± g·ªëc
        selected_questions.sort(key=lambda x: int(x[0]) if x[0].isdigit() else float('inf'))
        
        for num, body, q_text in selected_questions:
            # Ki·ªÉm tra tr√πng s·ªë Question (ch·ªâ khi kh√¥ng ƒë√°nh s·ªë l·∫°i)
            if not renumber and num in seen_numbers:
                original_num = num
                counter = 1
                while f"{num}_{counter}" in seen_numbers or num in seen_numbers:
                    counter += 1
                new_num = f"{original_num}_{counter}"
                number_conflicts.append(f"Question {original_num} tr√πng s·ªë ‚Üí ƒë·ªïi th√†nh Question {new_num}")
                num = new_num
            
            if not renumber:
                seen_numbers[num] = 1
            unique_blocks.append((num, body, q_text))

        # B∆∞·ªõc 4: ƒê√°nh s·ªë l·∫°i t·ª´ 1 n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
        if renumber:
            print("üî¢ ƒê√°nh s·ªë l·∫°i t·ª´ Question 1, 2, 3...")
            renumbered_blocks = []
            for i, (old_num, body, q_text) in enumerate(unique_blocks, 1):
                renumbered_blocks.append((str(i), body, q_text))
            unique_blocks = renumbered_blocks

        return {
            'unique_blocks': unique_blocks,
            'removed_blocks': removed,
            'incorrect_questions': incorrect,
            'format_errors': [],
            'total_questions': len(questions),
            'duplicate_info': dup_info,
            'number_conflicts': number_conflicts,
            'renumbered': renumber
        }

    def _write_text(self, filename: str, data: Dict) -> None:
        """Ghi file text - gi·ªØ nguy√™n ƒë·ªãnh d·∫°ng ban ƒë·∫ßu"""
        with open(filename, "w", encoding="utf-8") as f:
            for q_num, content, _ in data['unique_blocks']:
                f.write(f"Question {q_num}\n{content}\n\n")

    def write_output(self, filename: str, data: Dict) -> None:
        ext = Path(filename).suffix.lower()
        if ext == '.json':
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        elif ext == '.csv':
            import csv
            with open(filename, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(['Question_ID', 'Content'])
                for q_num, content, _ in data['unique_blocks']:
                    writer.writerow([q_num, content.replace('\n', ' | ')])
        else:
            self._write_text(filename, data)

    def write_log(self, data: Dict, markers: List[str]) -> None:
        try:
            with open(self.log_file, "w", encoding="utf-8") as log:
                log.write(f"üìä X·ª≠ l√Ω l√∫c {datetime.datetime.now()}\n")
                log.write(f"T·ªïng: {data['total_questions']}, H·ª£p l·ªá: {len(data['unique_blocks'])}, Lo·∫°i: {data['removed_blocks'] + len(data['incorrect_questions'])}\n")
                
                if data['incorrect_questions']:
                    log.write("‚ùå C√¢u sai:\n" + "\n".join(f"  - {q}" for q in data['incorrect_questions']) + "\n")
                
                if data['duplicate_info']:
                    log.write("üîÅ C√¢u tr√πng n·ªôi dung:\n" + "\n".join(f"  - {info}" for info in data['duplicate_info']) + "\n")
                
                # Th√™m th√¥ng tin v·ªÅ xung ƒë·ªôt s·ªë Question
                if data.get('number_conflicts'):
                    log.write("‚ö†Ô∏è Xung ƒë·ªôt s·ªë Question:\n" + "\n".join(f"  - {conflict}" for conflict in data['number_conflicts']) + "\n")
                
                # Th√™m th√¥ng tin v·ªÅ th·ª© t·ª± c√¢u h·ªèi ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp
                log.write("üìã Th·ª© t·ª± c√¢u h·ªèi trong output:\n")
                for i, (q_num, _, q_text) in enumerate(data['unique_blocks'], 1):
                    log.write(f"  {i}. Question {q_num}: {q_text[:50]}{'...' if len(q_text) > 50 else ''}\n")
                
                # Th√™m th·ªëng k√™ v·ªÅ d·∫•u "-"
                dash_count = 0
                for q_num, body, q_text in data['unique_blocks']:
                    lines = body.splitlines()
                    if any(line.strip().startswith('-') for line in lines[2:] if line.strip()):
                        dash_count += 1
                
                log.write(f"\nüìä Th·ªëng k√™ d·∫•u '-': {dash_count}/{len(data['unique_blocks'])} c√¢u c√≥ ƒë√°p √°n d·∫°ng '-'\n")
        except:
            pass

    def run(self) -> None:
        print("üîç L·ªçc c√¢u h·ªèi tr√πng & sai (∆Øu ti√™n d·∫•u '-')")
        config = self.load_config()
        self.input_file = self.get_input_file()
        if not self.input_file:
            return
        config['last_input_file'] = self.input_file
        
        if config.get("auto_backup", True):
            bkup = self.backup_file(self.input_file)
            if bkup:
                print(f"üì¶ Backup: {bkup}")
        
        content = self.read_input_file(self.input_file)
        if not content: return
        
        is_valid, errs = self.validate_content(content)
        if not is_valid:
            print("‚ùå L·ªói:\n" + "\n".join(f"  - {e}" for e in errs))
            return
        
        content = self.fix_content_format(content)
        output = self.get_output_filename(config)
        markers = self.get_invalid_markers(config)
        
        # H·ªèi v·ªÅ vi·ªác ƒë√°nh s·ªë l·∫°i
        renumber = self.get_sort_preference(config)
        config['renumber_questions'] = renumber
        self.save_config(config)
        
        print("‚è≥ ƒêang x·ª≠ l√Ω...")
        questions = self.parse_questions(content)
        data = self.filter_questions(questions, markers, renumber)
        
        print(f"üìä T·ªïng: {data['total_questions']}, Gi·ªØ: {len(data['unique_blocks'])}, Lo·∫°i: {data['removed_blocks'] + len(data['incorrect_questions'])}")
        
        # Hi·ªÉn th·ªã th·ªëng k√™ d·∫•u "-"
        dash_count = 0
        for q_num, body, q_text in data['unique_blocks']:
            lines = body.splitlines()
            if any(line.strip().startswith('-') for line in lines[2:] if line.strip()):
                dash_count += 1
        print(f"üéØ C√¢u c√≥ d·∫•u '-': {dash_count}/{len(data['unique_blocks'])}")
        
        # Hi·ªÉn th·ªã th√¥ng tin xung ƒë·ªôt s·ªë Question n·∫øu c√≥
        if data.get('number_conflicts') and not data.get('renumbered'):
            print("‚ö†Ô∏è Ph√°t hi·ªán tr√πng s·ªë Question:")
            for conflict in data['number_conflicts']:
                print(f"  - {conflict}")
        
        # Hi·ªÉn th·ªã preview th·ª© t·ª± c√¢u h·ªèi
        if data['unique_blocks']:
            mode_desc = "ƒë√°nh s·ªë l·∫°i t·ª´ 1" if data.get('renumbered') else "gi·ªØ s·ªë g·ªëc"
            print(f"üìã Preview c√¢u h·ªèi ({mode_desc}):")
            for i, (q_num, body, q_text) in enumerate(data['unique_blocks'][:5], 1):
                # Hi·ªÉn th·ªã c√≥ d·∫•u "-" hay kh√¥ng
                lines = body.splitlines()
                has_dash = any(line.strip().startswith('-') for line in lines[2:] if line.strip())
                dash_indicator = " üéØ" if has_dash else ""
                print(f"  {i}. Question {q_num}{dash_indicator}: {q_text[:40]}{'...' if len(q_text) > 40 else ''}")
            if len(data['unique_blocks']) > 5:
                print(f"  ... v√† {len(data['unique_blocks']) - 5} c√¢u kh√°c")
        
        if input("‚úÖ Ghi file? (y/n): ").strip().lower() in ['y', 'yes', '']:
            self.write_output(output, data)
            self.write_log(data, markers)
            print(f"üéâ Xong! File: {output}")

if __name__ == "__main__":
    QuestionFilter().run()
